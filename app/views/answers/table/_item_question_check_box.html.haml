%label.main(for="answer_#{question.key}")= raw(question.title)
.description-and-fields(style="width=#{fields_width};")
  .fields(id="answer_#{question.key}_input")
    - opt_len = question.options.length
    - columns = question.table.columns || opt_len
    - col_len = (opt_len / columns.to_f).ceil
    - (0...col_len).each do |j|
      - (0...columns).each do |i|
        - break if j + i*col_len >= opt_len
        - opt = question.options[j + i*col_len]
        - if opt.inner_title
          .inner-title
            :markdown
              #{raw opt.description}
        - else
          - checked = @answer.send(opt.key) == 1
          - next if( opt.hidden and not checked)
          - optionclasses = ["optionwidth#{columns}"]
          - optionclasses << "first" if i == 0
          .option(class = optionclasses)
            .radiocheckwrapper
              - if question.uncheck_all_option == opt.key
                -attrs = {:onClick => "setAllCheckboxes(this.checked, '#{question.check_all_option}', '#{question.uncheck_all_option}', '#{question.key}', ''); handleDisableCheckboxSubQuestions(this);"}
              - elsif question.check_all_option == opt.key
                -attrs = {:onClick => "setAllCheckboxes(this.checked, '#{question.check_all_option}', '#{question.uncheck_all_option}', '#{question.key}', '1'); handleDisableCheckboxSubQuestions(this);"}
              - else
                -attrs = {:onClick => "correctAllNothingCheckboxes(this.checked, '#{question.check_all_option}', '#{question.uncheck_all_option}'); handleDisableCheckboxSubQuestions(this);"}
              = check_box(:answer, "#{opt.key}", attrs)
              
            -if question.table.show_option_desc
              .labelwrapper
                %label(for="answer_#{opt.key}")
                  %span
                    :markdown
                      #{raw opt.description}