- question = nil
- reset_cycle "opt_set_hcycle"
- reset_cycle "opt_set_rcycle"
- reset_cycle "opt_set_cycle"
%table
  %tbody
    - table.rows.each_with_index do |opt_sets, rowi|
      - filled_columns = 0        
      - header = ''
      - all_blank = true
      - opt_sets.each_with_index do |opt_set, i|
        - os_cycle = cycle("light", "dark", :name => "opt_set_hcycle" )      
        - last = opt_set == opt_sets.last
        - colspan = opt_set.length.to_f
        - question = get_question(table, rowi, i)
        - if (rowi == 0 or different_header(question, get_question(table, rowi-1, i))) and question.score_header != :none
          - header += render :partial => "answers/table/item_table_header", :locals => {:question => question, :last => last, :colspan => colspan, :os_cycle => os_cycle}
          - all_blank = false
        - else
          - header += render :partial => "answers/table/item_table_header", :locals => {:question => nil, :colspan => colspan, :os_cycle => os_cycle}
          
      - question = get_question(table, rowi, 0)
      - same_question = (rowi != 0 and question.key == get_question(table, rowi-1, 0).key)
      
      - if question.presentation == :horizontal and not same_question
        - if rowi == 0
          %caption
            %div.main(class = "horizontal")
              %label(for="answer_#{question.key}")
                :markdown
                  #{question.title}
        - else
          %tr.row
            %td.main{:class => "horizontal", :colspan => table.columns}
              %label(for="answer_#{question.key}")
                :markdown
                  #{question.title}
      
      - if not all_blank 
        %tr.option_sets.row
          - unless question.andand.presentation == :horizontal
            %th.main
          = raw header
      
      - cls = []
      - if opt_sets.length <= 1 and not same_question
        - os_cycle = cycle("light", "dark", :name => "opt_set_rcycle" )
      - else 
        - os_cycle = nil
      - cls << os_cycle
      - cls << 'inner_row' if opt_sets != table.rows.last and question == get_question(table, rowi+1, 0)
      %tr.row(class = cls)
        - unless question.presentation == :horizontal
          - unless same_question
            - rowspan = (question.options.length.to_f/table.columns).ceil
            - rowspan = 1 if question.type == :select
            - title_insert = nil
            - subq = question.options.last.andand.questions.andand.first
            - if subq.andand.presentation == :next_to_title and subq.type == :string
              - title_insert = render :partial => "answers/shared/inline_text_field", :locals => {:title => subq.title, :answer => @answer, :question => subq}
            :markdown
              #{table_marukufix question.title, "answer_#{question.key}", rowspan, title_insert}
                
        - reset_cycle "opt_set_cycle" if os_cycle != "dark"
        - opt_sets.each_with_index do |opt_set, j| 
          - os_cycle = !same_question ? cycle("light", "dark", :name => "opt_set_cycle" ) : ''
          - question = get_question(table, rowi, j)
          - opt_set.each_with_index do |opt, i|
            - validations = render :partial => 'answers/shared/validations', :locals => {:question => question, :answer => @answer}
                    
            - case question.type
            - when :check_box
              = render :partial => "answers/table/item_option_check_box", :locals => {:opt => opt, :table => table, :os_cycle => os_cycle, :validations => validations, :question => question}
            - when :radio, :scale
              = render :partial => "answers/table/item_option_radio", :locals => {:opt => opt, :table => table, :os_cycle => os_cycle, :validations => validations, :question => question}
            - when :string
              = render :partial => "answers/table/item_question_string", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
            - when :textarea
              = render :partial => "answers/table/item_question_textarea", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
            - when :integer, :float
              = render :partial => "answers/table/item_question_number", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
            - when :date
              = render :partial => "answers/table/item_question_date", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
            - when :select
              = render :partial => "answers/table/item_question_select", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
            - when :quantity
              = render :partial => "answers/table/item_question_quantity", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
            - else
              %strong
                Error: unknown question type
                = question.type
                for question
                = question.key
            - filled_columns += 1
            - if opt == opt_set.last and opt_set == opt_sets.last and filled_columns < table.columns
              - (0...(table.columns - filled_columns)).each do 
                %td
                  