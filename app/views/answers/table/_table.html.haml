- question = nil
- previous_row = nil
- reset_cycle "opt_set_hcycle"
- reset_cycle "opt_set_rcycle"
- reset_cycle "opt_set_cycle"
%table
  - table.rows.each_with_index do |opt_sets, rowi|
    - filled_columns = 0
        
    - header = ''
    - all_blank = true
    - opt_sets.each_with_index do |opt_set, i|
      - os_cycle = cycle("light", "dark", :name => "opt_set_hcycle" )      
      - last = opt_set == opt_sets.last
      - if opt_set.class.name == "QuestionOption"
        - fail Exception.new("#{rowi}, #{i}")
      - colspan = opt_set.length.to_f
      - if not previous_row or different_header(get_question(opt_set[0]), get_question(previous_row[i][0]))
        - header += render :partial => "answers/table/item_table_header", :locals => {:question => get_question(opt_set[0]), :last => last, :colspan => colspan, :os_cycle => os_cycle}
        - all_blank = false
      - else
        - header += render :partial => "answers/table/item_table_header", :locals => {:question => nil, :colspan => colspan, :os_cycle => os_cycle}
    
    - question = get_question(opt_sets[0][0])
    - same_question = (rowi != 0 and question.key == get_question(table.rows[rowi-1][0][0]).key)
    
    - if question.presentation == :horizontal
      - if rowi == 0
        %caption
          %div.main(class = "horizontal")
            - unless same_question
              %label(for="answer_#{question.key}")= raw(question.title)
      - else
        %tr.row
          %td.main{:class => "horizontal", :colspan => table.columns}
            - unless same_question
              %label(for="answer_#{question.key}")= raw(question.title)
    
    - if not all_blank or rowi == 0
      %tr.option_sets.row
        - unless question.andand.presentation == :horizontal
          %th.main
        = raw header
    - previous_row = opt_sets
    - cls = []
    - if opt_sets.length <= 1 and not same_question
      - os_cycle = cycle("light", "dark", :name => "opt_set_rcycle" )
    - else 
      - os_cycle = nil
    - cls << os_cycle
    - cls << 'inner_row' if opt_sets != table.rows.last and get_question(opt_sets[0][0]) == get_question(table.rows[rowi+1][0][0])
    %tr.row(class = cls)
      - unless question.presentation == :horizontal
        %td.main
          - unless same_question
            %div
              %label(for="answer_#{question.key}")= raw(question.title)
      - reset_cycle "opt_set_cycle" if os_cycle != "dark"
      - opt_sets.each do |opt_set| 
        - os_cycle = !same_question ? cycle("light", "dark", :name => "opt_set_cycle" ) : ''
        - opt_set.each_with_index do |opt, i|
          - question = get_question(opt)
          - validations = capture do
            - question.validations.each do |validation|
              - exp_classes = ["error", validation[:type]]
              - valtypes = @answer.errors[question.key].collect{|e| e[:valtype]}
              - unless valtypes.include?(validation[:type])
                - exp_classes << "hidden" 
              - case validation[:type]
              - when :maximum
                %span{:class => exp_classes}= validation[:explanation] || "Uw antwoord moet een getal kleiner dan of gelijk aan #{validation[:value]} zijn." 
              - when :minimum
                %span{:class => exp_classes}= validation[:explanation] || "Uw antwoord moet een getal groter dan of gelijk aan #{validation[:value]} zijn."
              - when :requires_answer
                %span{:class => exp_classes}= validation[:explanation] || "Deze vraag moet beantwoord worden."
              - when :regexp
                %span{:class => exp_classes}= validation[:explanation] || "Uw antwoord moet voldoen aan de vorm #{validation[:matcher]}."
              - when :valid_integer
                %span{:class => exp_classes}= validation[:explanation] || "Uw antwoord moet een afgerond getal zijn."
              - when :valid_float
                %span{:class => exp_classes}= validation[:explanation] || "Uw antwoord moet een getal zijn (gebruik een decimale punt voor kommagetallen)."
              - when :too_many_checked
                %span{:class => exp_classes}= validation[:explanation] || "U heeft te veel opties gekozen."
              - when :not_all_checked
                %span{:class => exp_classes}= validation[:explanation] || "U heeft te weinig opties gekozen."
              - when :one_of
                %span{:class => exp_classes}= validation[:explanation] || "Uw antwoord moet een van de volgende zijn: #{validation[:array].inspect}"
              - when :answer_group_minimum 
                %span{:class => exp_classes}= validation[:explanation] || "Beantwoord minstens #{validation[:value]} van deze vragen"
              - when :answer_group_maximum
                %span{:class => exp_classes}= validation[:explanation] || "Beantwoord hoogstens #{validation[:value]} van deze vragen"
              - else
                %strong
                  Error: unknown validation type
                  = validation[:type]
                  
          - case question.type
          - when :check_box
            = render :partial => "answers/table/item_option_check_box", :locals => {:opt => opt, :table => table, :os_cycle => os_cycle, :validations => validations}
          - when :radio, :scale
            = render :partial => "answers/table/item_option_radio", :locals => {:opt => opt, :table => table, :os_cycle => os_cycle, :validations => validations}
          - when :string
            = render :partial => "answers/table/item_question_string", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
          - when :textarea
            = render :partial => "answers/table/item_question_textarea", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
          - when :integer, :float
            = render :partial => "answers/table/item_question_number", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
          - when :date
            = render :partial => "answers/table/item_question_date", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
          - when :select
            = render :partial => "answers/table/item_question_select", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
          - when :quantity
            = render :partial => "answers/table/item_question_quantity", :locals => {:question => question, :table => table, :os_cycle => os_cycle, :validations => validations}
          - else
            %strong
              Error: unknown question type
              = question.type
              for question
              = question.key
          - filled_columns += 1
          - if opt == opt_set.last and opt_set == opt_sets.last and filled_columns < table.columns
            - (0...(table.columns - filled_columns)).each do 
              %td
                