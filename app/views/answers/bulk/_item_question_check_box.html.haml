%label.main(for="answer_#{question.key}")= raw(question.title)
.description-and-fields
  .description
    - unless question.description.blank?
      :markdown
        #{raw question.description}
  .fields(id="answer_#{question.key}_input")
    - question.options.each do |opt|
      - next if opt.inner_title
      - checked = @answer.send(opt.key) == 1
      - next if( opt.hidden and not checked)
      .option{ :for => question.key}
        .radiocheckwrapper
          - if question.uncheck_all_option == opt.key
            -attrs = {:onClick => "setAllCheckboxes(this.checked, '#{question.check_all_option}', '#{question.uncheck_all_option}', '#{question.key}', ''); handleDisableCheckboxSubQuestions(this);", :class => subquestion ? "subinput" : ""}
          - elsif question.check_all_option == opt.key
            -attrs = {:onClick => "setAllCheckboxes(this.checked, '#{question.check_all_option}', '#{question.uncheck_all_option}', '#{question.key}', '1'); handleDisableCheckboxSubQuestions(this);", :class => subquestion ? "subinput" : ""}
          - else
            -attrs = {:onClick => "correctAllNothingCheckboxes(this.checked, '#{question.check_all_option}', '#{question.uncheck_all_option}'); handleDisableCheckboxSubQuestions(this);", :class => subquestion ? "subinput" : ""}
          -if disabled
            -attrs[:disabled] = ""
          = check_box(:answer, "#{opt.key}", attrs)
        .labelwrapper
          %label(for="answer_#{opt.key}")
            %span
              :markdown
                #{raw opt.description}
        - unless opt.questions.empty?
          .subquestions= render :partial => "answers/bulk/item", :collection => opt.questions,  :locals => {:subquestion => true, :disabled => !checked}
