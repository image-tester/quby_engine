- if not question.disallow_bulk and question.subquestions.blank?
  - if (not previous_item) or |
       (not previous_item.respond_to?(:options)) or |
       (    previous_item.options.map(&:value) != question.options.map(&:value) | 
        and previous_item.options.map(&:description) != question.options.map(&:description) |
       )
    = render :partial => "answers/bulk/item_radio_check_scale_options", :object => question

  %label.main(for="answer_#{question.key}")= question.title
  .description-and-fields
    .fields(id="answer_#{question.key}_input" class="options#{question.options.size}")
      - question.options.each_with_index do |opt, idx|
        - cls = []
        - cls << "first" if idx <= 0
        - cls << "last" if idx >= (question.options.size - 1)
        .option(class=cls)
        - radio_classes = []
        - radio_classes << "subinput" if subquestion
        - radio_classes << "deselectable" if question.deselectable
          = radio_button(:answer, question.key, opt.key,
          {:onClick => "handleDisableRadioSubQuestions(this); handleHideQuestions(this,#{opt.hides_questions.to_json}, #{question.hides_questions.to_json})", :class => radio_classes})
- else
  - content_for(:item_class, "notbulk")
  %label.main(for="answer_#{question.key}")= question.title
  .description-and-fields
    .description
      - unless question.description.blank?
        :markdown
          #{raw question.description}
    .fields(id="answer_#{question.key}_input")
      - question.options.each do |opt|
        - if opt.inner_title
          .inner-title
            :markdown
              #{raw opt.description}
        - else
          .option(class="#{question.show_values ? 'show_values' : nil}")
            .radiocheckwrapper
              = radio_button(:answer, question.key, opt.key,
                {:onClick => "handleDisableRadioSubQuestions(this); handleHideQuestions(this,#{opt.hides_questions.to_json}, #{question.hides_questions.to_json})", :class => subquestion ? "subinput" : ""})
            - if question.show_values
              .value= opt.value
            %label(for="answer_#{question.key}_#{opt.key}")
              %span
                :markdown
                  #{raw opt.description}
            - unless opt.questions.empty?
              .subquestions= render :partial => "answers/paged/item", :collection => opt.questions,  :locals => {:subquestion => true}
