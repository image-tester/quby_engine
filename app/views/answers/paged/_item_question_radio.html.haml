%label.main(for="answer_#{question.key}")= question.title
.description-and-fields
  .description
    - unless question.description.blank?
      :markdown
        #{raw question.description}
  .fields(id="answer_#{question.key}_input")
    - question.options.each do |opt|
      - if opt.inner_title
        .inner-title
          :markdown
            #{raw opt.description}
      - else
        .option(class="#{question.show_values ? 'show_values' : nil}")
          .radiocheckwrapper
            - radio_classes = []
            - radio_classes << "subinput" if subquestion
            - radio_classes << "deselectable" if question.deselectable
            = radio_button(:answer, question.key, opt.key,
              {:onClick => "handleDisableRadioSubQuestions(this); handleHideQuestions(this,#{opt.hides_questions.to_json}, #{question.hides_questions.to_json})", :class => radio_classes})
          - if question.show_values
            .value= opt.value
          %label(for="answer_#{question.key}_#{opt.key}")
            %span
              :markdown
                #{raw opt.description}
          - unless opt.questions.empty?
            .subquestions= render :partial => "answers/paged/item", :collection => opt.questions,  :locals => {:subquestion => true}
    = radio_button_tag(question.key, "DESELECTED_RADIO_VALUE", false, :class => "hidden", :name => "answer[#{question.key}]")